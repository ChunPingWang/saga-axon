# 功能規格：Saga 訂單交易協調

**功能分支**: `001-saga-order-transaction`
**建立日期**: 2025-12-07
**狀態**: 草稿
**輸入**: 使用者描述：「Monorepo 微服務銷售系統 MVP - 跨服務訂單交易協調」

<!--
  語言要求（憲法第 IX 條）：本規格全文必須以繁體中文撰寫。
  僅技術識別碼（API 名稱、程式碼片段）可保留英文。
-->

## 使用者情境與測試 *(必填)*

### 使用者故事 1 - 成功訂購商品 (優先級: P1)

身為一位顧客，我想要訂購一支 iPhone 17，系統會自動協調支付預留與庫存確認，當兩者皆成功時完成訂單，讓我能夠順利完成購買流程。

**優先級原因**: 這是 MVP 的核心價值主張。若無法完成成功的訂購流程，系統將毫無用處。這是最基本且最重要的功能。

**獨立測試**: 可透過發送訂購請求並驗證訂單狀態為「已確認」來完全測試，並確認支付已扣款且庫存已減少。

**驗收情境**:

1. **Given** 顧客有足夠的信用卡額度且 iPhone 17 有庫存，**When** 顧客發送訂購請求，**Then** 系統建立訂單、預留信用額度、確認庫存後完成交易，訂單狀態為「已確認」
2. **Given** 訂單正在處理中，**When** 支付服務與庫存服務皆在 15 秒內回覆成功，**Then** 系統發送確認訊息給兩個服務並完成交易

---

### 使用者故事 2 - 支付或庫存失敗時取消交易 (優先級: P2)

身為一位顧客，當我的信用卡額度不足或商品無庫存時，系統應自動取消整筆交易並回復所有已預留的資源，讓我不會被錯誤扣款或產生不一致的訂單狀態。

**優先級原因**: 補償機制是 Saga 模式的核心。若無法正確處理失敗情境，將導致資料不一致，嚴重影響系統可靠性與使用者信任。

**獨立測試**: 可透過模擬支付失敗或庫存不足的情境，驗證訂單狀態為「已取消」且所有預留資源已釋放。

**驗收情境**:

1. **Given** 顧客發送訂購請求，**When** 支付服務回覆額度不足，**Then** 系統取消訂單並通知庫存服務釋放任何已預留的庫存
2. **Given** 顧客發送訂購請求，**When** 庫存服務回覆無庫存，**Then** 系統取消訂單並通知支付服務釋放已預留的信用額度
3. **Given** 支付預留成功但庫存確認失敗，**When** 系統執行補償，**Then** 支付預留被取消，訂單狀態為「已取消」

---

### 使用者故事 3 - 超時自動取消交易 (優先級: P3)

身為一位顧客，當支付或庫存服務因任何原因未能在合理時間內回應時，系統應自動取消交易，避免我的資源被無限期鎖定。

**優先級原因**: 超時處理確保系統在服務異常時仍能維持一致性，防止資源永久鎖定。這是系統韌性的關鍵要素。

**獨立測試**: 可透過模擬服務延遲超過 15 秒，驗證系統自動發送取消訊息且訂單狀態為「已取消」。

**驗收情境**:

1. **Given** 顧客發送訂購請求，**When** 支付服務超過 15 秒未回覆，**Then** 系統自動發送取消訊息給所有相關服務並將訂單標記為「已取消（超時）」
2. **Given** 顧客發送訂購請求，**When** 庫存服務超過 15 秒未回覆，**Then** 系統自動發送取消訊息給所有相關服務並將訂單標記為「已取消（超時）」
3. **Given** 支付服務已預留成功但庫存服務超時，**When** 超時觸發，**Then** 系統發送取消訊息釋放已預留的支付額度

---

### 邊界情況

- 若支付與庫存服務同時失敗，系統如何處理？（預期：訂單取消，無需補償操作）
- 若補償訊息發送失敗，系統如何確保最終一致性？（預期：實作基本重試機制，固定重試 3 次，若仍失敗則記錄並標記待處理）
- 若服務在超時臨界點回覆，系統如何處理競態條件？（預期：以先到達的結果為準）
- 若同一商品同時有多筆訂單，庫存如何避免超賣？（預期：樂觀鎖定或庫存預留機制）

## 需求 *(必填)*

### 功能需求

- **FR-001**: 系統必須提供訂購介面，接受顧客的商品訂購請求
- **FR-002**: 系統必須在收到訂購請求後，同時向支付服務與庫存服務發送非同步訊息
- **FR-003**: 系統必須向支付服務請求預留指定金額（本案例為 35,000 元）
- **FR-004**: 系統必須向庫存服務請求確認指定商品（iPhone 17）的可用庫存
- **FR-005**: 當支付預留與庫存確認皆成功時，系統必須發送確認訊息給兩個服務以完成交易
- **FR-006**: 當支付或庫存任一服務回覆失敗時，系統必須發送取消訊息給所有相關服務
- **FR-007**: 當任一服務超過 15 秒未回覆時，系統必須視為失敗並發送取消訊息
- **FR-008**: 系統必須追蹤每筆訂單的狀態（待處理、處理中、已確認、已取消）
- **FR-009**: 系統必須記錄所有交易步驟與結果，供後續查詢與稽核
- **FR-010**: 補償訊息發送失敗時，系統必須自動重試最多 3 次，若仍失敗則記錄並標記為「待人工處理」

### 關鍵實體

- **訂單（Order）**: 代表一筆顧客訂購請求，包含訂單編號、顧客資訊、商品明細、金額、狀態、建立時間
- **支付預留（PaymentReservation）**: 代表信用卡額度的暫時鎖定，包含預留編號、訂單編號、金額、狀態、過期時間
- **庫存預留（InventoryReservation）**: 代表商品庫存的暫時鎖定，包含預留編號、訂單編號、商品編號、數量、狀態
- **Saga 執行紀錄（SagaExecution）**: 代表一次 Saga 協調流程，包含 Saga 編號、訂單編號、目前步驟、各步驟狀態、最終結果

### 領域模型 *(DDD 對齊)*

**限界上下文**:

- **銷售上下文（Sales Context）**: 負責訂單管理與 Saga 協調
- **支付上下文（Payment Context）**: 負責信用額度預留與確認
- **庫存上下文（Inventory Context）**: 負責商品庫存預留與扣減

**通用語言**:
- **預留（Reserve）**: 暫時鎖定資源（額度或庫存），尚未實際扣減
- **確認（Confirm）**: 正式完成交易，將預留轉為實際扣減
- **補償（Compensate）**: 釋放已預留的資源，回復到交易前狀態
- **Saga**: 一連串需要協調的本地交易，確保跨服務的最終一致性

**聚合根**:
- **訂單聚合（Order Aggregate）**: 保護訂單不變量：訂單狀態轉換必須合法、金額必須為正數
- **支付預留聚合（PaymentReservation Aggregate）**: 保護預留不變量：預留金額不得超過可用額度
- **庫存預留聚合（InventoryReservation Aggregate）**: 保護庫存不變量：預留數量不得超過可用庫存

**領域事件**:
- **OrderCreated**: 訂單建立時發出
- **PaymentReserved / PaymentReservationFailed**: 支付預留結果
- **InventoryReserved / InventoryReservationFailed**: 庫存預留結果
- **OrderConfirmed**: 訂單確認完成
- **OrderCancelled**: 訂單取消
- **SagaTimedOut**: Saga 超時觸發

### 使用者體驗需求 *(必填)*

- **UX-001**: 訂購請求發送後，使用者必須在 3 秒內收到訂單已受理的回應（非最終結果）
- **UX-002**: 訂單最終結果（成功或失敗）必須透過通知機制告知使用者（MVP 以 Mock WebSocket 模擬即時推送）
- **UX-003**: 使用者必須能夠查詢訂單目前狀態與歷史紀錄
- **UX-004**: 錯誤訊息必須清楚說明失敗原因（如「信用額度不足」、「商品已售完」、「服務暫時無法使用」）

### 效能需求 *(必填)*

- **PERF-001**: 訂購請求的初始回應時間必須在 3 秒內（p95）
- **PERF-002**: 完整的 Saga 流程（從訂購到最終確認/取消）必須在 30 秒內完成
- **PERF-003**: 系統必須支援每秒 100 筆並發訂購請求
- **PERF-004**: 超時檢測精確度必須在 ±1 秒內

## 成功標準 *(必填)*

### 可衡量成果

- **SC-001**: 使用者可在 3 秒內收到訂單受理確認，完整交易流程在 30 秒內完成
- **SC-002**: 成功交易場景中，支付與庫存狀態 100% 一致（無資料不一致情況）
- **SC-003**: 失敗或超時場景中，100% 的預留資源在 1 分鐘內被正確釋放
- **SC-004**: 系統可處理每秒 100 筆並發訂購請求，無效能劣化
- **SC-005**: 所有交易步驟與結果皆有完整紀錄，可供稽核查詢

## 釐清事項

### Session 2025-12-07

- Q: MVP 範圍內，補償訊息發送失敗時的處理方式為何？ → A: 實作基本重試（固定次數，如 3 次）
- Q: MVP 中，訂單結果通知使用者的方式為何？ → A: 先以 Mock 方式模擬 WebSocket 處理

## 假設與限制

### 假設

- MVP 階段僅支援單一商品（iPhone 17）訂購
- 每筆訂單固定金額為 35,000 元
- 使用者認證與授權由外部系統處理，本功能假設請求已通過驗證
- 微服務間透過訊息佇列進行非同步通訊
- 每個微服務有獨立的資料儲存
- MVP 通知機制以 Mock WebSocket 實作，預留未來替換為真實 WebSocket 的介面

### 限制

- MVP 不支援部分付款或分期付款
- MVP 不支援購物車功能（僅單一商品訂購）
- MVP 不支援訂單修改，僅能取消後重新訂購
- 補償失敗時實作基本重試（固定 3 次），超過次數後記錄並標記待人工處理
